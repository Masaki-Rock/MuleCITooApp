/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package mule.ci.tool.app;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import mule.ci.tool.app.api.APIManagerAPICaller;
import mule.ci.tool.app.api.CloudhubAPICaller;
import mule.ci.tool.app.api.ExchangeAPICaller;
import mule.ci.tool.app.api.GithubAPICaller;
import mule.ci.tool.app.api.model.APIAssetsResponse;
import mule.ci.tool.app.api.model.ApplicationResponse;
import mule.ci.tool.app.api.model.ExchangeAssetResponse;
import mule.ci.tool.app.api.model.GithubReleaseResponse;
import mule.ci.tool.app.util.AppException;
import mule.ci.tool.app.util.Const;

public class App {

	private static final Logger log = LoggerFactory.getLogger(App.class);

	private static Map<String, String> apiIds;

	/**
	 * メイン処理
	 * 
	 * @param args 引数
	 */
	public static void main(String[] args) {

		try {
			CommandLine line = setMenue(args);
			taskControler(line);
		} catch (AppException e) {
			log.error(e.getMessage());
		}
	}

	/**
	 * サービスメニュー設定処理
	 * 
	 * @param args 引数
	 * @return 実行コマンド解析結果
	 * @throws AppException アプリケーション例外
	 */
	private static CommandLine setMenue(String[] args) throws AppException {

		CommandLineParser parser = new DefaultParser();
		CommandLine line = null;
		try {
			line = parser.parse(setOptions(), args);
		} catch (ParseException e) {
			throw new AppException(e);
		}
		return line;
	}

	/**
	 * 提供サービス
	 * 
	 * @return サービス群
	 */
	private static Options setOptions() {
		Options options = new Options();
		options.addOption("all", false, "Perform all tasks.");
		options.addOption("save", true,
				"to register. <all|apiInstance|slaTiers|policies|alerts|application|runtimeAlerts>");
		options.addOption("update", true, "to update. <all|apiInstance|application>");
		options.addOption("delete", true,
				"to delete. <all|apiInstance|slaTiers|policies|alerts|application|runtimeAlerts>");
		options.addOption("gitupload", false,"Upload the application file to the release folder.");
		options.addOption("gitdownload", false,"Download the application file from the release folder.");
		options.addOption("gitrelease", false,"Release the application files in the release folder.");
		options.addOption("config", true, "Specifying the path of the project configuration file.");
		options.addOption("help", false, "Show all menue.");
		options.addOption("org", true, "Business Group settings.");
		options.addOption("env", true, "Environment settings.");
		options.addOption("type", true, "Worker size setting.");
		options.addOption("workers", true, "Worker amount setting.");
		options.addOption("gitfolder", true, "Specify the release folder.");
		options.addOption("gitpre", true, "Specify the pre-release.");
		options.addOption("gitbranch", true, "Specify the target brunch.");
		options.addOption("gitapp", true, "Specify the github application file.");
		options.addOption("gittoken", true, "Specify GITHUB_TOKEN..");
		return options;
	}

	/**
	 * サービス実行制御
	 * 
	 * @param line 実行コマンド
	 * @throws AppException アプリケーション例外
	 */
	private static void taskControler(CommandLine line) throws AppException {

		executeSettingsMenue(line);
		executeDeleteMenue(line);
		executeSaveMenue(line);
		executeUpdateMenue(line);
		if (line.hasOption("all")) {
			log.info("all process start!!");
			APIAssetsResponse param = new APIManagerAPICaller().findAPIInstance();
			apiIds = param.getApiIds();
			init();
			log.info("save process finished!!");
		}
		executeGithubMenue(line);
		if (line.hasOption("help")) {
			HelpFormatter formatter = new HelpFormatter();
			formatter.printHelp("Mule CD Tool", setOptions());
		}
	}
	private static void executeSettingsMenue(CommandLine line) throws AppException {
		if (line.hasOption("config")) {
			String projectpath = line.getOptionValue("config");
			Path projectfile = Paths.get(projectpath);
			log.info("Project file path is {}", projectpath);
			if (!projectfile.toFile().exists()) {
				throw new AppException(String.format("{} Project file does not exist.", projectfile.toString()));
			}
			Const.PROJECT_YAML_FILE_PATH = projectfile.toString();
			Const.setProjectSettings();
		}
		if (line.hasOption("org")) {
			String bussinesGroupName = line.getOptionValue("org");
			Const.BUSSINES_GROUP_NAME = bussinesGroupName;
			Const.setOrganization();
			log.info("Bussines Group Name is {}.", Const.BUSSINES_GROUP_NAME);
		}
		if (line.hasOption("env")) {
			String environmentName = line.getOptionValue("env");
			Const.ENVIRONMENT_NAME = environmentName;
			Const.setOrganization();
			log.info("Environment Name is {}.", Const.ENVIRONMENT_NAME);
		}
		if (line.hasOption("type")) {
			String workerType = line.getOptionValue("type");
			Const.WORKER_TYPE = workerType;
			log.info("Worker size is {}.", Const.WORKER_TYPE);
		}
		if (line.hasOption("workers")) {
			String workers = line.getOptionValue("workers");
			Const.WORKERS = Integer.valueOf(workers);
			log.info("Workers is {}.", Const.WORKERS);
		}
		if (line.hasOption("gitfolder")) {
			String foldername = line.getOptionValue("gitfolder");
			Const.GITHUB_RELEASE_NAME = foldername;
			log.info("Github Release folder is {}.", foldername);
		}
		if (line.hasOption("gitpre")) {
			String preReleaseFlag = line.getOptionValue("gitpre");
			if (StringUtils.isNoneBlank(preReleaseFlag)) {
				Const.GITHUB_RELEASE_FLAG = false;
			}
			log.info("Github Pre-Release Flag is {}.", preReleaseFlag);
		}
		if (line.hasOption("gitbranch")) {
			String branch = line.getOptionValue("gitbranch");
			Const.GITHUB_BRANCH = branch;
			log.info("Github Branch is {}.", branch);
		}
		if (line.hasOption("gitapp")) {
			String filePath = line.getOptionValue("gitapp");
			Const.GITHUB_APPLICATION_FILE_PATH = filePath;
			log.info("Github Application file is {}.", filePath);
		}
		if (line.hasOption("gittoken")) {
			String token = line.getOptionValue("gittoken");
			Const.GITHUB_ACCESS_TOKEN = token;
			log.info("Github token is setted.");
		}
	}
	private static void executeDeleteMenue(CommandLine line) throws AppException {
		if (line.hasOption("delete")) {
			log.info("delete process start!!");
			String taskname = line.getOptionValue("delete");

			APIAssetsResponse param = new APIManagerAPICaller().findAPIInstance();
			apiIds = param.getApiIds();

			if (StringUtils.equals("all", taskname)) {
				deleteAll();
			}
			if (StringUtils.equals("runtimeAlerts", taskname)) {
				deleteRuntimeAlerts();
			}
			if (StringUtils.equals("application", taskname)) {
				deleteApplication();
			}
			if (StringUtils.equals("alerts", taskname)) {
				deleteAlerts();
			}
			if (StringUtils.equals("policies", taskname)) {
				deletePolicies();
			}
			if (StringUtils.equals("slaTiers", taskname)) {
				deleteSLATiers();
			}
			if (StringUtils.equals("apiInstance", taskname)) {
				deleteAPIInstance();
			}
			log.info("delete process finished!!");
		}
	}
	private static void executeSaveMenue(CommandLine line) throws AppException {
		if (line.hasOption("save")) {
			log.info("save process start!!");
			String taskname = line.getOptionValue("save");

			APIAssetsResponse param = new APIManagerAPICaller().findAPIInstance();
			apiIds = param.getApiIds();

			if (StringUtils.equals("all", taskname)) {
				saveRuntimeAlerts();
				saveAPIInstance();
				saveSLATiers();
				savePolicies();
				saveAlerts();
				saveApplication();
			}
			if (StringUtils.equals("runtimeAlert", taskname)) {
				saveRuntimeAlerts();
			}
			if (StringUtils.equals("application", taskname)) {
				saveApplication();
			}
			if (StringUtils.equals("alerts", taskname)) {
				saveAlerts();
			}
			if (StringUtils.equals("policies", taskname)) {
				savePolicies();
			}
			if (StringUtils.equals("tiers", taskname)) {
				saveSLATiers();
			}
			if (StringUtils.equals("apiInstance", taskname)) {
				saveAPIInstance();
			}
			log.info("save process finished!!");
		}
	}
	private static void executeUpdateMenue(CommandLine line) throws AppException {
		if (line.hasOption("update")) {
			log.info("update process start!!");
			String taskname = line.getOptionValue("update");

			APIAssetsResponse param = new APIManagerAPICaller().findAPIInstance();
			apiIds = param.getApiIds();

			if (StringUtils.equals("all", taskname)) {
				updateApplication();
				updateAPIInstance();
			}
			if (StringUtils.equals("application", taskname)) {
				updateApplication();
			}
			if (StringUtils.equals("apiInstance", taskname)) {
				updateAPIInstance();
			}
			log.info("update process finished!!");
		}
	}
	private static void executeGithubMenue(CommandLine line) throws AppException {
		
		if (line.hasOption("gitupload")) {
			log.info("git Upload process start!!");
			uploadApplicationFile();
			log.info("git Upload process finished!!");
		}
		if (line.hasOption("gitdownload")) {
			log.info("git Download process start!!");
			downloadApplicationFile();
			log.info("git Download process finished!!");
		}
		if (line.hasOption("gitrelease")) {
			log.info("git Release process start!!");
			releaseApplicationFile();
			log.info("git Release process finished!!");
		}
	}

	/**
	 * 初期メソッド
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void init() throws AppException {

		if (apiIds == null || apiIds.isEmpty()) {
			saveAPIInstance();
		}
		deleteSLATiers();
		saveSLATiers();
		deletePolicies();
		savePolicies();
		deleteAlerts();
		saveAlerts();
		deleteRuntimeAlerts();
		saveRuntimeAlerts();
		if (existApplication()) {
			updateApplication();
		} else {
			saveApplication();
		}
	}
	
	/**
	 * 初期メソッド
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void updateMuleAPI() throws AppException {

		if (apiIds == null || apiIds.isEmpty()) {
			saveAPIInstance();
			saveSLATiers();
			savePolicies();
			saveAlerts();
		}
		if (existApplication()) {
			updateApplication();
		} else {
			saveApplication();
		}
	}

	/**
	 * 全削除処理
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void deleteAll() throws AppException {

		deleteRuntimeAlerts();
		deleteApplication();
		deleteAPIInstance();
	}

	/**
	 * APIインスタンス登録機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void saveAPIInstance() throws AppException {

		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			Map<String, String> ins = (Map<String, String>) Const.API_INSTANCES.get(apiInstanceName);
			caller.saveAPIInstance(ins.get("assetId"), ins.get("apiInstanceLabel"));
		}
		APIAssetsResponse param = caller.findAPIInstance();
		apiIds = param.getApiIds();
	}

	/**
	 * APIインスタンス更新機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void updateAPIInstance() throws AppException {

		ExchangeAPICaller excaller = new ExchangeAPICaller();
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			Map<String, String> ins = (Map<String, String>) Const.API_INSTANCES.get(apiInstanceName);
			ExchangeAssetResponse exres = excaller.findAsset(ins.get("assetId"));
			caller.updateAPIInstance(apiIds.get(apiInstanceName), exres.getVersion());
		}
	}

	/**
	 * APIインスタンス削除機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void deleteAPIInstance() throws AppException {

		if (apiIds == null || apiIds.isEmpty())
			return;
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			caller.deleteAPIInstance(apiIds.get(apiInstanceName));
		}
	}

	/**
	 * SLA層登録昨日
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void saveSLATiers() throws AppException {

		if (apiIds == null || apiIds.isEmpty())
			return;
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			caller.saveSLATiers(apiIds.get(apiInstanceName));
		}
	}

	/**
	 * SLA層削除機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void deleteSLATiers() throws AppException {

		if (apiIds == null || apiIds.isEmpty())
			return;
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			caller.deleteSLATiers(apiIds.get(apiInstanceName));
		}
	}

	/**
	 * ポリシー登録機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void savePolicies() throws AppException {

		if (apiIds == null || apiIds.isEmpty())
			return;
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			caller.savePolicies(apiIds.get(apiInstanceName));
		}
	}

	/**
	 * ポリシー削除機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void deletePolicies() throws AppException {

		if (apiIds == null || apiIds.isEmpty())
			return;
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			caller.deletePolicies(apiIds.get(apiInstanceName));
		}
	}

	/**
	 * アラート登録機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void saveAlerts() throws AppException {

		if (apiIds == null || apiIds.isEmpty())
			return;
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			caller.saveAlerts(apiIds.get(apiInstanceName), apiInstanceName);
		}
	}

	/**
	 * 全アラート削除機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void deleteAlerts() throws AppException {

		if (apiIds == null || apiIds.isEmpty())
			return;
		APIManagerAPICaller caller = new APIManagerAPICaller();
		for (String apiInstanceName : Const.API_INSTANCES.keySet()) {
			caller.deleteAlerts(apiIds.get(apiInstanceName));
		}
	}

	/**
	 * アプリケーション存在チェック機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static Boolean existApplication() throws AppException {

		CloudhubAPICaller caller = new CloudhubAPICaller();
		ApplicationResponse application = caller.findApplication(Const.ENV_DOMAIN);
		if (application == null) {
			return false;
		}
		return true;
	}

	/**
	 * アプリケーション登録機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void saveApplication() throws AppException {

		APIManagerAPICaller apicaller = new APIManagerAPICaller();
		APIAssetsResponse res = apicaller.findAPIInstance();
		CloudhubAPICaller caller = new CloudhubAPICaller();
		caller.saveApplication(Const.ENV_DOMAIN, res.getApiIds());
	}

	/**
	 * アプリケーション更新機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void updateApplication() throws AppException {

		APIManagerAPICaller apicaller = new APIManagerAPICaller();
		APIAssetsResponse res = apicaller.findAPIInstance();
		CloudhubAPICaller caller = new CloudhubAPICaller();
		caller.updateApplication(Const.ENV_DOMAIN, res.getApiIds());
	}

	/**
	 * アプリケーション削除機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void deleteApplication() throws AppException {

		CloudhubAPICaller caller = new CloudhubAPICaller();
		caller.deleteApplication(Const.ENV_DOMAIN);
	}

	/**
	 * ランタイムアラート登録機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void saveRuntimeAlerts() throws AppException {

		CloudhubAPICaller caller = new CloudhubAPICaller();
		caller.saveRuntimeAlerts();
	}

	/**
	 * ランタイムアラート削除機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void deleteRuntimeAlerts() throws AppException {

		CloudhubAPICaller caller = new CloudhubAPICaller();
		caller.deleteRuntimeAlerts();
	}
	
	/**
	 * リリースフォルダへアプリケーションファイルアップロード機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void uploadApplicationFile() throws AppException {

		GithubAPICaller caller = new GithubAPICaller();
		GithubReleaseResponse release = caller.getRelease(Const.GITHUB_RELEASE_NAME);
		if (release == null) {
			release = caller.saveRelease(Const.GITHUB_RELEASE_NAME, Const.GITHUB_RELEASE_FLAG, Const.GITHUB_BRANCH);
		}
		Calendar cl = Calendar.getInstance();
		SimpleDateFormat sdf = new SimpleDateFormat("MMddHHmmss");
		String filename = String.format(Const.GITHUB_APPLICATION_FILE_NAME, sdf.format(cl.getTime()));
		caller.saveAssets(release.getId(), Const.APPLICATION_FILE_PATH, filename);
	}
	
	/**
	 * アプリケーションダウンロード機能
	 * 
	 * @return ダウンロードファイル名
	 * @throws AppException アプリケーション例外
	 */
	public static String downloadApplicationFile() throws AppException {

		GithubAPICaller caller = new GithubAPICaller();
		List<Map<String, Object>> assets = caller.findAsset(Const.GITHUB_RELEASE_NAME);
		List<String> fnamelist = new ArrayList<String>();
		String expr = String.format(Const.GITHUB_APPLICATION_FILE_NAME, "[\\d]+\\");
		for (Map<String, Object> asset: assets) {
			String filename = (String) asset.get("name");
			if (filename.matches(expr)) {
				fnamelist.add(filename);
			}
		}
		Collections.reverse(fnamelist);
		if (fnamelist.isEmpty()) {
			return null;
		}
		String filepath = fnamelist.get(0);
		if (StringUtils.isNoneBlank(Const.GITHUB_APPLICATION_FILE_PATH)) {
			filepath = Const.GITHUB_APPLICATION_FILE_PATH;
		}
		caller.getAssets(Const.GITHUB_RELEASE_NAME, filepath, filepath);
		return filepath;
	}
	/**
	 * アプリケーションリリース機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void releaseApplicationFile() throws AppException {

		Const.APPLICATION_FILE_PATH = downloadApplicationFile();
		APIAssetsResponse param = new APIManagerAPICaller().findAPIInstance();
		apiIds = param.getApiIds();
		updateMuleAPI();
	}
}
